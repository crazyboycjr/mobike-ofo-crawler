整个工程目录结构如下:
.
├── main.go
├── mobike
│   ├── loadtoken.go
│   └── mobike.go
├── ofo
│   └── ofo.go
├── README.md
├── token.txt.example
└── utility
    └── request.go

其中README.md介绍了基本的构建和使用方法
token.txt.example里是token存放的格式
其余都是源代码

main.go用来处理命令行参数，并且调用相应的模块(mobike, ofo)执行

utility/request.go实现了一些辅助函数，用来发送HTTP请求
mobike/loadtoken.go读取命令行执行的token文件，默认是$PWD下的token.txt

剩下mobike.go和ofo.go整体框架类似
Run()函数开始整个流程的执行
以mobike.go举例，140行到151行是生成坐标，并打乱顺序
接下来定义了两个channel，一个存放请求(request)，一个存放回应(response)
想象多生产者多消费者模型，每个channel可以理解为buffer，在这个程序里这就是一个大小为0的buffer(东西放进去没人取就会阻塞，不过这个大小不是很重要)，在这里一个只有两个buffer，一个用来待请求的坐标，一个存放API返回结果
为了优化mobike爬虫的请求次数，我们假定每次请求的半径，如果真实返回结果在假定半径范围内的车辆大于某个阈值，则在这个范围内继续四分
这就要求之后每次请求都和之前返回结果有关。
于是需要两条buffer，生产者从结果buffer中拿返回值，并且生成新的请求塞到请求buffer中，消费者从请求buffer中拿请求，然后发给API，把结果存到结果buffer中
构成一个循环
接下来为了实现n的并发，只要启动n个生产者，n个消费者即可，go中对应的就是n个goroutine，代码对应156到159行

又因为一开始两个队列都是空的，所以需要往请求队列里塞刚刚生成的坐标。


                               +-------+
    +--------------------<-----|Channel|<----------------------+
    |        +-----------<-----|  res  |<--------------+       |
	|        |                 +-------+               |       |
    |        v                                         |       ^
    |  +--------+                                  +--------+  |
    |  |Producer|--->--+                     +---->|Consumer|  |
    |  +--------+      |                     |     +--------+  |
    |                  |       +-------+     |                 |
    |  +--------+      +------>|Channel|-->--+     +--------+  |
    +->|Producer|--->--------->|  req  |-->--------|Consumer|--+
       +--------+              +-------+           +--------+
                                   ^^
                                   ||
                           +----------------+
                           | init generator |
                           +----------------+

整个流程如图所示，如果还是不太明白，可以学习一下Gorouting或者CSP模型

至于produce函数中间95到118行，是对返回的数据转化成json的处理, 104, 105两行将结果写入文件，如果想存成其他格式，可以在这个地方进行修改
